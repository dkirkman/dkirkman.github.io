{"version":3,"sources":["webpack://EmscriptenWebpack/./build/libTest.js","webpack://EmscriptenWebpack/./node_modules/path-browserify/index.js"],"names":["module","exports","Module","key","moduleOverrides","hasOwnProperty","status","toThrow","nodeFS","nodePath","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","Error","window","importScripts","process","filename","binary","ret","__webpack_require__","toString","buffer","Uint8Array","assert","length","replace","slice","ex","ExitStatus","reason","p","read","f","data","readbuffer","scriptArgs","arguments","quit","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","onload","onerror","title","document","console","log","bind","print","printErr","warn","undefined","STACK_ALIGN","staticAlloc","size","staticSealed","STATICTOP","alignMemory","factor","Math","ceil","warnOnce","text","shown","stackSave","abort","Array","ABORT","condition","Pointer_stringify","ptr","t","hasUtf","i","TOTAL_MEMORY","HEAPU8","curr","String","fromCharCode","apply","subarray","min","UTF8ArrayToString","UTF8ToString","UTF8Decoder","TextDecoder","u8Array","idx","endPtr","decode","u0","u1","u2","u3","u4","str","ch","demangleAll","x","func","y","stackTrace","js","err","stack","e","jsStackTrace","HEAP16","HEAP32","HEAPU32","STACK_BASE","STACKTOP","STACK_MAX","DYNAMIC_BASE","DYNAMICTOP_PTR","WASM_PAGE_SIZE","ASMJS_PAGE_SIZE","updateGlobalBufferViews","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","checkStackCookie","abortOnCannotGrowMemory","enlargeMemory","TOTAL_STACK","prototype","set","byteLength","WebAssembly","Memory","initial","maximum","ArrayBuffer","callRuntimeCallbacks","callbacks","callback","shift","arg","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATEXIT__","__ATPOSTRUN__","runtimeInitialized","runtimeExited","abs","cos","sin","tan","acos","asin","atan","atan2","exp","sqrt","floor","pow","imul","fround","round","max","clz32","trunc","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","FS","error","init","createDataFile","createPreloadedFile","createLazyFile","mkdev","registerDevice","analyzePath","loadFilesFromDB","ErrnoError","dataURIPrefix","isDataURI","startsWith","indexOf","wasmTextFile","wasmBinaryFile","asmjsCodeFile","info","global","env","asm2wasm","f64-rem","debugger","parent","mergeMemory","newBuffer","oldBuffer","buf","oldView","getBinary","doNativeWasm","providedBuffer","receiveInstance","instance","memory","id","clearInterval","removeRunDependency","NaN","Infinity","setInterval","dep","trueModule","receiveInstantiatedSource","output","instantiateArrayBuffer","receiver","fetch","Promise","resolve","reject","credentials","then","catch","instantiate","instantiateStreaming","asmjsReallocBuffer","finalMethod","multiple","PAGE_MULTIPLE","oldSize","grow","wasmReallocBuffer","TABLE_SIZE","MAX_TABLE_SIZE","Table","element","integrateWasmJS","STATIC_BASE","push","tempDoublePtr","SYSCALLS","varargs","get","getStr","get64","low","high","getZero","flush_NO_FILESYSTEM","fflush","printChar","___syscall146","buffers","which","stream","iov","iovcnt","len","j","errno","asmGlobalArg","asmLibraryArg","getTotalMemory","abortStackOverflow","allocSize","nullFunc_ii","nullFunc_iiii","invoke_ii","index","a1","invoke_iiii","a2","a3","___lock","___setErrNo","value","___syscall140","getStreamFromFD","offset_low","result","whence","offset","llseek","position","getdents","___syscall54","___syscall6","close","___unlock","_emscripten_memcpy_big","dest","src","num","asm","real____errno_location","real__add_values","real__fflush","real__free","real__malloc","real__sbrk","real_establishStackSpace","real_getTempRet0","real_setTempRet0","real_setThrew","real_stackAlloc","real_stackRestore","real_stackSave","initialStackTop","this","name","message","Object","defineProperty","old","constructor","run","args","doRun","cb","unshift","postRun","preRun","setTimeout","runCaller","implicit","has","checkUnflushedContent","abortDecorators","what","JSON","stringify","forEach","decorator","pop","normalizeArray","parts","allowAboveRoot","up","last","splice","splitPathRe","splitPath","exec","filter","xs","res","resolvedPath","resolvedAbsolute","path","cwd","TypeError","charAt","split","join","normalize","isAbsolute","trailingSlash","substr","paths","call","relative","from","to","trim","arr","start","end","fromParts","toParts","samePartsLength","outputParts","concat","sep","delimiter","dirname","root","dir","basename","ext","extname"],"mappings":"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","file":"libTest-45777a0c84d6fccefb18.js","sourcesContent":["var Module = function(Module) {\n  Module = Module || {};\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nModule['arguments'] = [];\nModule['thisProgram'] = './this.program';\nModule['quit'] = function(status, toThrow) {\n  throw toThrow;\n};\nModule['preRun'] = [];\nModule['postRun'] = [];\n\n// The environment setup code below is customized to use Module.\n// *** Environment setup code ***\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\nif (Module['ENVIRONMENT']) {\n  if (Module['ENVIRONMENT'] === 'WEB') {\n    ENVIRONMENT_IS_WEB = true;\n  } else if (Module['ENVIRONMENT'] === 'WORKER') {\n    ENVIRONMENT_IS_WORKER = true;\n  } else if (Module['ENVIRONMENT'] === 'NODE') {\n    ENVIRONMENT_IS_NODE = true;\n  } else if (Module['ENVIRONMENT'] === 'SHELL') {\n    ENVIRONMENT_IS_SHELL = true;\n  } else {\n    throw new Error('Module[\\'ENVIRONMENT\\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');\n  }\n} else {\n  ENVIRONMENT_IS_WEB = typeof window === 'object';\n  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n}\n\n\nif (ENVIRONMENT_IS_NODE) {\n  // Expose functionality in the same simple way that the shells work\n  // Note that we pollute the global namespace here, otherwise we break in node\n  var nodeFS;\n  var nodePath;\n\n  Module['read'] = function shell_read(filename, binary) {\n    var ret;\n      if (!nodeFS) nodeFS = require('fs');\n      if (!nodePath) nodePath = require('path');\n      filename = nodePath['normalize'](filename);\n      ret = nodeFS['readFileSync'](filename);\n    return binary ? ret : ret.toString();\n  };\n\n  Module['readBinary'] = function readBinary(filename) {\n    var ret = Module['read'](filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n\n  if (process['argv'].length > 1) {\n    Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  Module['arguments'] = process['argv'].slice(2);\n\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  // Currently node will swallow unhandled rejections, but this behavior is\n  // deprecated, and in the future it will exit with error status.\n  process['on']('unhandledRejection', function(reason, p) {\n    Module['printErr']('node.js exiting due to unhandled promise rejection');\n    process['exit'](1);\n  });\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n} else\nif (ENVIRONMENT_IS_SHELL) {\n  if (typeof read != 'undefined') {\n    Module['read'] = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  Module['readBinary'] = function readBinary(f) {\n    var data;\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    Module['arguments'] = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    Module['arguments'] = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    Module['quit'] = function(status, toThrow) {\n      quit(status);\n    }\n  }\n} else\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  Module['read'] = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    Module['readBinary'] = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  Module['setWindowTitle'] = function(title) { document.title = title };\n} else\n{\n  throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n}\n\n// console.log is checked first, as 'print' on the web will open a print dialogue\n// printErr is preferable to console.warn (works better in shells)\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\nModule['print'] = typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null);\nModule['printErr'] = typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || Module['print']);\n\n// *** Environment setup code ***\n\n// Closure helpers\nModule.print = Module['print'];\nModule.printErr = Module['printErr'];\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = undefined;\n\n\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n// stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\nstackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function() {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  assert(!staticSealed);\n  var ret = STATICTOP;\n  STATICTOP = (STATICTOP + size + 15) & -16;\n  return ret;\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  if (end >= TOTAL_MEMORY) {\n    var success = enlargeMemory();\n    if (!success) {\n      HEAP32[DYNAMICTOP_PTR>>2] = ret;\n      return 0;\n    }\n  }\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  var ret = size = Math.ceil(size / factor) * factor;\n  return ret;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    Module.printErr(text);\n  }\n}\n\n\n\nvar jsCallStartIndex = 1;\nvar functionPointers = new Array(0);\n\n// 'sig' parameter is only used on LLVM wasm backend\nfunction addFunction(func, sig) {\n  if (typeof sig === 'undefined') {\n    Module.printErr('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but is required for the LLVM wasm backend, so it is recommended for full portability.');\n  }\n  var base = 0;\n  for (var i = base; i < base + 0; i++) {\n    if (!functionPointers[i]) {\n      functionPointers[i] = func;\n      return jsCallStartIndex + i;\n    }\n  }\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n}\n\nfunction removeFunction(index) {\n  functionPointers[index-jsCallStartIndex] = null;\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    assert(args.length == sig.length-1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // FIXME backwards compatibility layer for ports. Support some Runtime.*\n  //       for now, fix it there, then remove it from here. That way we\n  //       can minimize any period of breakage.\n  dynCall: dynCall, // for SDL2 port\n  // helpful errors\n  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\n\n//========================================\n// Runtime essentials\n//========================================\n\nvar ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\nvar globalScope = this;\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\nvar JSfuncs = {\n  // Helpers for cwrap -- it can't refer to Runtime directly because it might\n  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n  // out what the minified function name is.\n  'stackSave': function() {\n    stackSave()\n  },\n  'stackRestore': function() {\n    stackRestore()\n  },\n  // type conversion from js to c\n  'arrayToC' : function(arr) {\n    var ret = stackAlloc(arr.length);\n    writeArrayToMemory(arr, ret);\n    return ret;\n  },\n  'stringToC' : function(str) {\n    var ret = 0;\n    if (str !== null && str !== undefined && str !== 0) { // null string\n      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n      var len = (str.length << 2) + 1;\n      ret = stackAlloc(len);\n      stringToUTF8(str, ret, len);\n    }\n    return ret;\n  }\n};\n\n// For fast lookup of conversion functions\nvar toC = {\n  'string': JSfuncs['stringToC'], 'array': JSfuncs['arrayToC']\n};\n\n// C calling interface.\nfunction ccall (ident, returnType, argTypes, args, opts) {\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n  if (returnType === 'string') ret = Pointer_stringify(ret);\n  else if (returnType === 'boolean') ret = Boolean(ret);\n  if (stack !== 0) {\n    stackRestore(stack);\n  }\n  return ret;\n}\n\nfunction cwrap (ident, returnType, argTypes) {\n  argTypes = argTypes || [];\n  var cfunc = getCFunc(ident);\n  // When the function takes numbers and returns a number, we can just return\n  // the original function\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\n  var numericRet = returnType !== 'string';\n  if (numericRet && numericArgs) {\n    return cfunc;\n  }\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments);\n  }\n}\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_STATIC = 2; // Cannot be freed\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 4; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    assert(type, 'Must know what type to store in allocate!');\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!staticSealed) return staticAlloc(size);\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n/** @type {function(number, number=)} */\nfunction Pointer_stringify(ptr, length) {\n  if (length === 0 || !ptr) return '';\n  // Find the length, and check for UTF while doing so\n  var hasUtf = 0;\n  var t;\n  var i = 0;\n  while (1) {\n    assert(ptr + i < TOTAL_MEMORY);\n    t = HEAPU8[(((ptr)+(i))>>0)];\n    hasUtf |= t;\n    if (t == 0 && !length) break;\n    i++;\n    if (length && i == length) break;\n  }\n  if (!length) length = i;\n\n  var ret = '';\n\n  if (hasUtf < 128) {\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n    var curr;\n    while (length > 0) {\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n      ret = ret ? ret + curr : curr;\n      ptr += MAX_CHUNK;\n      length -= MAX_CHUNK;\n    }\n    return ret;\n  }\n  return UTF8ToString(ptr);\n}\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAP8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\nfunction UTF8ArrayToString(u8Array, idx) {\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  while (u8Array[endPtr]) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var u0, u1, u2, u3, u4, u5;\n\n    var str = '';\n    while (1) {\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n      u0 = u8Array[idx++];\n      if (!u0) return str;\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u3 = u8Array[idx++] & 63;\n        if ((u0 & 0xF8) == 0xF0) {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n        } else {\n          u4 = u8Array[idx++] & 63;\n          if ((u0 & 0xFC) == 0xF8) {\n            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\n          } else {\n            u5 = u8Array[idx++] & 63;\n            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\n          }\n        }\n      }\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ToString(ptr) {\n  return UTF8ArrayToString(HEAPU8,ptr);\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x1FFFFF) {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x3FFFFFF) {\n      if (outIdx + 4 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF8 | (u >> 24);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 5 >= endIdx) break;\n      outU8Array[outIdx++] = 0xFC | (u >> 30);\n      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      ++len;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else if (u <= 0x1FFFFF) {\n      len += 4;\n    } else if (u <= 0x3FFFFFF) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n  return len;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\nfunction demangle(func) {\n  warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n  return func;\n}\n\nfunction demangleAll(text) {\n  var regex =\n    /__Z[\\w\\d_]+/g;\n  return text.replace(regex,\n    function(x) {\n      var y = demangle(x);\n      return x === y ? x : (x + ' [' + y + ']');\n    });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error(0);\n    } catch(e) {\n      err = e;\n    }\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n  return demangleAll(js);\n}\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n  Module['buffer'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n  staticSealed = false;\n\n\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0);\n  HEAPU32[(STACK_MAX >> 2)-1] = 0x02135467;\n  HEAPU32[(STACK_MAX >> 2)-2] = 0x89BACDFE;\n}\n\nfunction checkStackCookie() {\n  if (HEAPU32[(STACK_MAX >> 2)-1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2)-2] != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2)-2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2)-1].toString(16));\n  }\n  // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n}\n\nfunction abortOnCannotGrowMemory() {\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\n\nfunction enlargeMemory() {\n  abortOnCannotGrowMemory();\n}\n\n\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\nif (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// Initialize the runtime's memory\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\n       'JS engine does not provide full typed array support');\n\n\n\n// Use a provided buffer, if there is one, or else allocate a new one\nif (Module['buffer']) {\n  buffer = Module['buffer'];\n  assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n} else {\n  // Use a WebAssembly memory where available\n  if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {\n    assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n    Module['wasmMemory'] = new WebAssembly.Memory({ 'initial': TOTAL_MEMORY / WASM_PAGE_SIZE, 'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE });\n    buffer = Module['wasmMemory'].buffer;\n  } else\n  {\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\n  }\n  assert(buffer.byteLength === TOTAL_MEMORY);\n  Module['buffer'] = buffer;\n}\nupdateGlobalBufferViews();\n\n\nfunction getTotalMemory() {\n  return TOTAL_MEMORY;\n}\n\n// Endianness check (note: assumes compiler arch was little-endian)\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\nHEAP16[1] = 0x6373;\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n  // compatibility - merge in anything from Module['preRun'] at this time\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n  checkStackCookie();\n  if (runtimeInitialized) return;\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATEXIT__);\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n  // compatibility - merge in anything from Module['postRun'] at this time\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\nassert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            Module.printErr('still waiting on run dependencies:');\n          }\n          Module.printErr('dependency: ' + dep);\n        }\n        if (shown) {\n          Module.printErr('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    Module.printErr('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    Module.printErr('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\n\nvar memoryInitializer = null;\n\n\n\nvar /* show errors on likely calls to FS when it was not included */ FS = {\n  error: function() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n  },\n  init: function() { FS.error() },\n  createDataFile: function() { FS.error() },\n  createPreloadedFile: function() { FS.error() },\n  createLazyFile: function() { FS.error() },\n  open: function() { FS.error() },\n  mkdev: function() { FS.error() },\n  registerDevice: function() { FS.error() },\n  analyzePath: function() { FS.error() },\n  loadFilesFromDB: function() { FS.error() },\n\n  ErrnoError: function ErrnoError() { FS.error() },\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nfunction integrateWasmJS() {\n  // wasm.js has several methods for creating the compiled code module here:\n  //  * 'native-wasm' : use native WebAssembly support in the browser\n  //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\n  //  * 'interpret-binary': load binary wasm and interpret\n  //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\n  //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\n  // The method is set at compile time (BINARYEN_METHOD)\n  // The method can be a comma-separated list, in which case, we will try the\n  // options one by one. Some of them can fail gracefully, and then we can try\n  // the next.\n\n  // inputs\n\n  var method = 'native-wasm';\n\n  var wasmTextFile = 'libTest.wast';\n  var wasmBinaryFile = 'libTest.wasm';\n  var asmjsCodeFile = 'libTest.temp.asm.js';\n\n  if (typeof Module['locateFile'] === 'function') {\n    if (!isDataURI(wasmTextFile)) {\n      wasmTextFile = Module['locateFile'](wasmTextFile);\n    }\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = Module['locateFile'](wasmBinaryFile);\n    }\n    if (!isDataURI(asmjsCodeFile)) {\n      asmjsCodeFile = Module['locateFile'](asmjsCodeFile);\n    }\n  }\n\n  // utilities\n\n  var wasmPageSize = 64*1024;\n\n  var info = {\n    'global': null,\n    'env': null,\n    'asm2wasm': { // special asm2wasm imports\n      \"f64-rem\": function(x, y) {\n        return x % y;\n      },\n      \"debugger\": function() {\n        debugger;\n      }\n    },\n    'parent': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n  };\n\n  var exports = null;\n\n\n  function mergeMemory(newBuffer) {\n    // The wasm instance creates its memory. But static init code might have written to\n    // buffer already, including the mem init file, and we must copy it over in a proper merge.\n    // TODO: avoid this copy, by avoiding such static init writes\n    // TODO: in shorter term, just copy up to the last static init write\n    var oldBuffer = Module['buffer'];\n    if (newBuffer.byteLength < oldBuffer.byteLength) {\n      Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n    }\n    var oldView = new Int8Array(oldBuffer);\n    var newView = new Int8Array(newBuffer);\n\n\n    newView.set(oldView);\n    updateGlobalBuffer(newBuffer);\n    updateGlobalBufferViews();\n  }\n\n  function fixImports(imports) {\n    return imports;\n  }\n\n  function getBinary() {\n    try {\n      if (Module['wasmBinary']) {\n        return new Uint8Array(Module['wasmBinary']);\n      }\n      if (Module['readBinary']) {\n        return Module['readBinary'](wasmBinaryFile);\n      } else {\n        throw \"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\";\n      }\n    }\n    catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    // if we don't have the binary yet, and have the Fetch api, use that\n    // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n    if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        if (!response['ok']) {\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n        }\n        return response['arrayBuffer']();\n      }).catch(function () {\n        return getBinary();\n      });\n    }\n    // Otherwise, getBinary should be able to get it synchronously\n    return new Promise(function(resolve, reject) {\n      resolve(getBinary());\n    });\n  }\n\n  // do-method functions\n\n\n  function doNativeWasm(global, env, providedBuffer) {\n    if (typeof WebAssembly !== 'object') {\n      // when the method is just native-wasm, our error message can be very specific\n      abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n      Module['printErr']('no native wasm support detected');\n      return false;\n    }\n    // prepare memory import\n    if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n      Module['printErr']('no native wasm Memory in use');\n      return false;\n    }\n    env['memory'] = Module['wasmMemory'];\n    // Load the wasm module and create an instance of using native support in the JS engine.\n    info['global'] = {\n      'NaN': NaN,\n      'Infinity': Infinity\n    };\n    info['global.Math'] = Math;\n    info['env'] = env;\n    // handle a generated wasm instance, receiving its exports and\n    // performing other necessary setup\n    function receiveInstance(instance, module) {\n      exports = instance.exports;\n      if (exports.memory) mergeMemory(exports.memory);\n      Module['asm'] = exports;\n      Module[\"usingWasm\"] = true;\n      removeRunDependency('wasm-instantiate');\n    }\n    addRunDependency('wasm-instantiate');\n\n    // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n    // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n    // to any other async startup actions they are performing.\n    if (Module['instantiateWasm']) {\n      try {\n        return Module['instantiateWasm'](info, receiveInstance);\n      } catch(e) {\n        Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);\n        return false;\n      }\n    }\n\n    // Async compilation can be confusing when an error on the page overwrites Module\n    // (for example, if the order of elements is wrong, and the one defining Module is\n    // later), so we save Module and check it later.\n    var trueModule = Module;\n    function receiveInstantiatedSource(output) {\n      // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n      // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n      assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n      trueModule = null;\n      receiveInstance(output['instance'], output['module']);\n    }\n    function instantiateArrayBuffer(receiver) {\n      getBinaryPromise().then(function(binary) {\n        return WebAssembly.instantiate(binary, info);\n      }).then(receiver).catch(function(reason) {\n        Module['printErr']('failed to asynchronously prepare wasm: ' + reason);\n        abort(reason);\n      });\n    }\n    // Prefer streaming instantiation if available.\n    if (!Module['wasmBinary'] &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: 'same-origin' }), info)\n        .then(receiveInstantiatedSource)\n        .catch(function(reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          Module['printErr']('wasm streaming compile failed: ' + reason);\n          Module['printErr']('falling back to ArrayBuffer instantiation');\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n    } else {\n      instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n    return {}; // no exports yet; we'll fill them in later\n  }\n\n\n  // We may have a preloaded value in Module.asm, save it\n  Module['asmPreload'] = Module['asm'];\n\n  // Memory growth integration code\n\n  var asmjsReallocBuffer = Module['reallocBuffer'];\n\n  var wasmReallocBuffer = function(size) {\n    var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n    size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n    var old = Module['buffer'];\n    var oldSize = old.byteLength;\n    if (Module[\"usingWasm\"]) {\n      // native wasm support\n      try {\n        var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n        if (result !== (-1 | 0)) {\n          // success in native wasm memory growth, get the buffer from the memory\n          return Module['buffer'] = Module['wasmMemory'].buffer;\n        } else {\n          return null;\n        }\n      } catch(e) {\n        console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize  + ' bytes to ' + size + ' bytes, but got error: ' + e);\n        return null;\n      }\n    }\n  };\n\n  Module['reallocBuffer'] = function(size) {\n    if (finalMethod === 'asmjs') {\n      return asmjsReallocBuffer(size);\n    } else {\n      return wasmReallocBuffer(size);\n    }\n  };\n\n  // we may try more than one; this is the final one, that worked and we are using\n  var finalMethod = '';\n\n  // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n  // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n  // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\n\n  Module['asm'] = function(global, env, providedBuffer) {\n    env = fixImports(env);\n\n    // import table\n    if (!env['table']) {\n      var TABLE_SIZE = Module['wasmTableSize'];\n      if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n      var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];\n      if (typeof WebAssembly === 'object' && typeof WebAssembly.Table === 'function') {\n        if (MAX_TABLE_SIZE !== undefined) {\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, 'maximum': MAX_TABLE_SIZE, 'element': 'anyfunc' });\n        } else {\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, element: 'anyfunc' });\n        }\n      } else {\n        env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n      }\n      Module['wasmTable'] = env['table'];\n    }\n\n    if (!env['memoryBase']) {\n      env['memoryBase'] = Module['STATIC_BASE']; // tell the memory segments where to place themselves\n    }\n    if (!env['tableBase']) {\n      env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\n    }\n\n    // try the methods. each should return the exports if it succeeded\n\n    var exports;\n    exports = doNativeWasm(global, env, providedBuffer);\n\n    assert(exports, 'no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');\n\n\n    return exports;\n  };\n\n  var methodHandler = Module['asm']; // note our method handler, as we may modify Module['asm'] later\n}\n\nintegrateWasmJS();\n\n// === Body ===\n\nvar ASM_CONSTS = [];\n\n\n\n\n\nSTATIC_BASE = GLOBAL_BASE;\n\nSTATICTOP = STATIC_BASE + 2704;\n/* global initializers */  __ATINIT__.push();\n\n\n\n\n\n\n\nvar STATIC_BUMP = 2704;\nModule[\"STATIC_BASE\"] = STATIC_BASE;\nModule[\"STATIC_BUMP\"] = STATIC_BUMP;\n\n/* no memory initializer */\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\n\nassert(tempDoublePtr % 8 == 0);\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n}\n\nfunction copyTempDouble(ptr) {\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n\n}\n\n// {{PRE_LIBRARY}}\n\n\n  function ___lock() {}\n\n  \n  var SYSCALLS={varargs:0,get:function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function () {\n        var ret = Pointer_stringify(SYSCALLS.get());\n        return ret;\n      },get64:function () {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function () {\n        assert(SYSCALLS.get() === 0);\n      }};function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // llseek\n      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();\n      // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n      var offset = offset_low;\n      FS.llseek(stream, offset, whence);\n      HEAP32[((result)>>2)]=stream.position;\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var printChar = ___syscall146.printChar;\n      if (!printChar) return;\n      var buffers = ___syscall146.buffers;\n      if (buffers[1].length) printChar(1, 10);\n      if (buffers[2].length) printChar(2, 10);\n    }function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // writev\n      // hack to support printf in NO_FILESYSTEM\n      var stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n      var ret = 0;\n      if (!___syscall146.buffers) {\n        ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr\n        ___syscall146.printChar = function(stream, curr) {\n          var buffer = ___syscall146.buffers[stream];\n          assert(buffer);\n          if (curr === 0 || curr === 10) {\n            (stream === 1 ? Module['print'] : Module['printErr'])(UTF8ArrayToString(buffer, 0));\n            buffer.length = 0;\n          } else {\n            buffer.push(curr);\n          }\n        };\n      }\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        for (var j = 0; j < len; j++) {\n          ___syscall146.printChar(stream, HEAPU8[ptr+j]);\n        }\n        ret += len;\n      }\n      return ret;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // ioctl\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // close\n      var stream = SYSCALLS.getStreamFromFD();\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___unlock() {}\n\n  \n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n      return dest;\n    } \n\n   \n\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\n      else Module.printErr('failed to set errno from JS');\n      return value;\n    } \nDYNAMICTOP_PTR = staticAlloc(4);\n\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\n\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\n\nDYNAMIC_BASE = alignMemory(STACK_MAX);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\nstaticSealed = true; // seal the static portion of memory\n\nassert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n\nvar ASSERTIONS = true;\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n\nfunction nullFunc_ii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nModule['wasmTableSize'] = 10;\n\nModule['wasmMaxTableSize'] = 10;\n\nfunction invoke_ii(index,a1) {\n  try {\n    return Module[\"dynCall_ii\"](index,a1);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiii(index,a1,a2,a3) {\n  try {\n    return Module[\"dynCall_iiii\"](index,a1,a2,a3);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nModule.asmGlobalArg = {};\n\nModule.asmLibraryArg = { \"abort\": abort, \"assert\": assert, \"enlargeMemory\": enlargeMemory, \"getTotalMemory\": getTotalMemory, \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory, \"abortStackOverflow\": abortStackOverflow, \"nullFunc_ii\": nullFunc_ii, \"nullFunc_iiii\": nullFunc_iiii, \"invoke_ii\": invoke_ii, \"invoke_iiii\": invoke_iiii, \"___lock\": ___lock, \"___setErrNo\": ___setErrNo, \"___syscall140\": ___syscall140, \"___syscall146\": ___syscall146, \"___syscall54\": ___syscall54, \"___syscall6\": ___syscall6, \"___unlock\": ___unlock, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM, \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR, \"tempDoublePtr\": tempDoublePtr, \"ABORT\": ABORT, \"STACKTOP\": STACKTOP, \"STACK_MAX\": STACK_MAX };\n// EMSCRIPTEN_START_ASM\nvar asm =Module[\"asm\"]// EMSCRIPTEN_END_ASM\n(Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n\nvar real____errno_location = asm[\"___errno_location\"]; asm[\"___errno_location\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____errno_location.apply(null, arguments);\n};\n\nvar real__add_values = asm[\"_add_values\"]; asm[\"_add_values\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__add_values.apply(null, arguments);\n};\n\nvar real__fflush = asm[\"_fflush\"]; asm[\"_fflush\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__fflush.apply(null, arguments);\n};\n\nvar real__free = asm[\"_free\"]; asm[\"_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__free.apply(null, arguments);\n};\n\nvar real__malloc = asm[\"_malloc\"]; asm[\"_malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__malloc.apply(null, arguments);\n};\n\nvar real__sbrk = asm[\"_sbrk\"]; asm[\"_sbrk\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__sbrk.apply(null, arguments);\n};\n\nvar real_establishStackSpace = asm[\"establishStackSpace\"]; asm[\"establishStackSpace\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_establishStackSpace.apply(null, arguments);\n};\n\nvar real_getTempRet0 = asm[\"getTempRet0\"]; asm[\"getTempRet0\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_getTempRet0.apply(null, arguments);\n};\n\nvar real_setTempRet0 = asm[\"setTempRet0\"]; asm[\"setTempRet0\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_setTempRet0.apply(null, arguments);\n};\n\nvar real_setThrew = asm[\"setThrew\"]; asm[\"setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_setThrew.apply(null, arguments);\n};\n\nvar real_stackAlloc = asm[\"stackAlloc\"]; asm[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackAlloc.apply(null, arguments);\n};\n\nvar real_stackRestore = asm[\"stackRestore\"]; asm[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackRestore.apply(null, arguments);\n};\n\nvar real_stackSave = asm[\"stackSave\"]; asm[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackSave.apply(null, arguments);\n};\nModule[\"asm\"] = asm;\nvar ___errno_location = Module[\"___errno_location\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"___errno_location\"].apply(null, arguments) };\nvar _add_values = Module[\"_add_values\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_add_values\"].apply(null, arguments) };\nvar _fflush = Module[\"_fflush\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_fflush\"].apply(null, arguments) };\nvar _free = Module[\"_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_free\"].apply(null, arguments) };\nvar _malloc = Module[\"_malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_malloc\"].apply(null, arguments) };\nvar _memcpy = Module[\"_memcpy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_memcpy\"].apply(null, arguments) };\nvar _memset = Module[\"_memset\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_memset\"].apply(null, arguments) };\nvar _sbrk = Module[\"_sbrk\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_sbrk\"].apply(null, arguments) };\nvar establishStackSpace = Module[\"establishStackSpace\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments) };\nvar getTempRet0 = Module[\"getTempRet0\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"getTempRet0\"].apply(null, arguments) };\nvar runPostSets = Module[\"runPostSets\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"runPostSets\"].apply(null, arguments) };\nvar setTempRet0 = Module[\"setTempRet0\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"setTempRet0\"].apply(null, arguments) };\nvar setThrew = Module[\"setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"setThrew\"].apply(null, arguments) };\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments) };\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments) };\nvar stackSave = Module[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments) };\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments) };\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments) };\n;\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\nif (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function() { abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function() { abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"ccall\"]) Module[\"ccall\"] = function() { abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"cwrap\"]) Module[\"cwrap\"] = function() { abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"setValue\"]) Module[\"setValue\"] = function() { abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getValue\"]) Module[\"getValue\"] = function() { abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"allocate\"]) Module[\"allocate\"] = function() { abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getMemory\"]) Module[\"getMemory\"] = function() { abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function() { abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function() { abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function() { abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function() { abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function() { abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function() { abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function() { abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function() { abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function() { abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function() { abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function() { abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function() { abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function() { abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function() { abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function() { abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function() { abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function() { abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function() { abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function() { abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function() { abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function() { abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function() { abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function() { abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function() { abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function() { abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS\"]) Module[\"FS\"] = function() { abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function() { abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function() { abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function() { abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function() { abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function() { abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function() { abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function() { abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function() { abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"GL\"]) Module[\"GL\"] = function() { abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"staticAlloc\"]) Module[\"staticAlloc\"] = function() { abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function() { abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function() { abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function() { abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function() { abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getLEB\"]) Module[\"getLEB\"] = function() { abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function() { abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function() { abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function() { abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addFunction\"]) Module[\"addFunction\"] = function() { abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function() { abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function() { abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function() { abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function() { abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"dynCall\"]) Module[\"dynCall\"] = function() { abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function() { abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackSave\"]) Module[\"stackSave\"] = function() { abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function() { abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function() { abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };if (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", { get: function() { abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", { get: function() { abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_STATIC\"]) Object.defineProperty(Module, \"ALLOC_STATIC\", { get: function() { abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", { get: function() { abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", { get: function() { abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\n\n\n\n// Modularize mode returns a function, which can be called to\n// create instances. The instances provide a then() method,\n// must like a Promise, that receives a callback. The callback\n// is called when the module is ready to run, with the module\n// as a parameter. (Like a Promise, it also returns the module\n// so you can use the output of .then(..)).\nModule['then'] = function(func) {\n  // We may already be ready to run code at this time. if\n  // so, just queue a call to the callback.\n  if (Module['calledRun']) {\n    func(Module);\n  } else {\n    // we are not ready to call then() yet. we must call it\n    // at the same time we would call onRuntimeInitialized.\n    var old = Module['onRuntimeInitialized'];\n    Module['onRuntimeInitialized'] = function() {\n      if (old) old();\n      func(Module);\n    };\n  }\n  return Module;\n};\n\n/**\n * @constructor\n * @extends {Error}\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n};\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\n\nvar initialStackTop;\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!Module['calledRun']) run();\n  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n}\n\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || Module['arguments'];\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n  function doRun() {\n    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    ensureInitRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n  checkStackCookie();\n}\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in NO_FILESYSTEM\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = Module['print'];\n  var printErr = Module['printErr'];\n  var has = false;\n  Module['print'] = Module['printErr'] = function(x) {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    var flush = flush_NO_FILESYSTEM;\n    if (flush) flush(0);\n  } catch(e) {}\n  Module['print'] = print;\n  Module['printErr'] = printErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent();\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && Module['noExitRuntime'] && status === 0) {\n    return;\n  }\n\n  if (Module['noExitRuntime']) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\n    }\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n    STACKTOP = initialStackTop;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  if (ENVIRONMENT_IS_NODE) {\n    process['exit'](status);\n  }\n  Module['quit'](status, new ExitStatus(status));\n}\nModule['exit'] = exit;\n\nvar abortDecorators = [];\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  if (what !== undefined) {\n    Module.print(what);\n    Module.printErr(what);\n    what = JSON.stringify(what)\n  } else {\n    what = '';\n  }\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  var extra = '';\n  var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n  if (abortDecorators) {\n    abortDecorators.forEach(function(decorator) {\n      output = decorator(output, what);\n    });\n  }\n  throw output;\n}\nModule['abort'] = abort;\n\n// {{PRE_RUN_ADDITIONS}}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n\nModule[\"noExitRuntime\"] = true;\n\nrun();\n\n// {{POST_RUN_ADDITIONS}}\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n\n\n  return Module;\n};\nif (typeof exports === 'object' && typeof module === 'object')\n    module.exports = Module;\n  else if (typeof define === 'function' && define['amd'])\n    define([], function() { return Module; });\n  else if (typeof exports === 'object')\n    exports[\"Module\"] = Module;\n  ","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n"],"sourceRoot":""}